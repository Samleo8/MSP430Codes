/***************************
 * IR_Board.C
 * Contains handlers for keypad GPIO and scanning
 *
 * Functions:
 *      Init_KeypadIO: Initializes keypad i/o
 *      Scan_Key: Scans to see which key on the matrix is pressed
 *
 * Connects to:
 *      LCD.c/h
 *      TempSensor.c/h
****************************/

#include "main.h"
#include "LCD.h"
#include "IR_Board.h"

/* KEYPAD SCAN METHOD
 * To scan which button is being pressed, a 4x4 matrix is used.
 * In pins (rows). Without any buttons pressed, the columns and rows are not connected to each other.
 * When a button is pressed, it connects its corresponding column pin with its corresponding row pin.
 * Configure the Keypad Out (column) pins as outputs, and Keypad In (row) pins as inputs.
 * The Keypad Out pins are toggled high one at a time, while the Keypad In pins are read for any changes.
 *  KEY-IN  = { 1.3 , 1.4 , 1.5 , 2.7 };
 *  KEY-OUT = { 8.1 , 1.1 , 8.0 , 2.5 };
 */

unsigned char key_num=0;
unsigned char buttonDebounce = 1;

void Init_KeypadIO(){
    // Configure Keypad GPIO
    //  KEYPAD IN  = { 1.3 , 1.4 , 1.5 , 2.7 };
    //  KEYPAD OUT = { 8.1 , 1.1 , 8.0 , 2.5 };

    //KEYPAD INPUT (P1.3/1.4/1.5/2.7)
    P1DIR &= ~(BIT3 | BIT4 | BIT5);             //Set as keypad input
    P2DIR &= ~BIT7;
    P1REN |= (BIT3 | BIT4 | BIT5);              //Set pull up resistor
    P2REN |= BIT7;
    P1OUT |= (BIT3 | BIT4 | BIT5);              //Pull-up to Vcc
    P2OUT |= BIT7;
    P1IES |= (BIT3 | BIT4 | BIT5);              //Enable high to low interrupt
    P2IES |= BIT7;
    P1IE  |= (BIT3 | BIT4 | BIT5);              //Enable P1.3/1.4/1.5/2.7 interrupt
    P2IE  |= BIT7;


    P8DIR |= (BIT0 + BIT1);                     //Set P8.0/8.1/1.1/2.5 as keypad output
    P1DIR |= BIT1;
    P2DIR |= BIT5;
    P8OUT &= ~(BIT0 + BIT1);                    //P8.0/8.1/1.1/2.5 output low
    P1OUT &= ~BIT1;
    P2OUT &= ~BIT5;

    //Clear Port 1 IFG
    P1IFG = 0;
    P2IFG = 0;
}

/* KEYPAD SCAN FUNCTION
 * To scan which button is being pressed, a 4x4 matrix is used.
 * In pins (rows). Without any buttons pressed, the columns and rows are not connected to each other.
 * When a button is pressed, it connects its corresponding column pin with its corresponding row pin.
 * Configure the Keypad Out (column) pins as outputs, and Keypad In (row) pins as inputs.
 * The Keypad Out pins are toggled high one at a time, while the Keypad In pins are read for any changes.
 *  KEY-IN  = { 1.3 , 1.4 , 1.5, 2.7 };
 *  KEY-OUT = { 8.1 , 1.1 , 8.0, 2.5 };
 *
 *  RETURNS:
 *      Key number from 1 to 16
 *      1 to 4: First row (1 is the first button from left)
 *      5 to 8: Second row
 *      9 to 12: Third row
 *      13 to 16: Fourth row
 */
unsigned char scan_key(void)
{
    unsigned char row_sel=0;
    unsigned char key_in=0;
    unsigned char keycol=0;
    unsigned char keyrow=0;
    unsigned char key_array[TOTAL_KEYS+1];
    unsigned char i=0;
    unsigned char j=0;

    // clear the array before scan
    for (i=TOTAL_KEYS ; i>=0 ; i--)
        key_array[i] = 0;

    keycol = BIT0;

    for (i = 0 ; i < KEYPAD_COLS ; i ++){
        P8DIR &= ~(BIT0 + BIT1);
        P1DIR &= ~BIT1;
        P2DIR &= ~BIT5;
        switch(i) {
            case 0:
                P8OUT &= ~BIT1;
                P8DIR |= BIT1;                      // select only one column
            case 1:
                P1OUT &= ~BIT1;
                P1DIR |= BIT1;                      // select only one column
            case 2:
                P8OUT &= ~BIT0;
                P8DIR |= BIT0;                      // select only one column
            case 3:
                P2OUT &= ~BIT5;
                P2DIR |= BIT5;                      // select only one column
        }
        __delay_cycles(100);

        key_in = (P1IN & 0x38) | (P2IN & 0x80); // get key input value

        if((key_in&0x08)!=0)                    // find the pressed button row
            row_sel|=0x08;
        if((key_in&0x10)!=0)
            row_sel|=0x04;
        if((key_in&0x20)!=0)
            row_sel|=0x02;
        if((key_in&0x80)!=0)
            row_sel|=0x01;
        keyrow = BIT3;

        for (j = 0 ; j< KEYPAD_ROWS ; j++)
        {
            if ((row_sel & keyrow) == 0)
                key_array[(j + i * KEYPAD_ROWS  + 1)] = 1;
            keyrow = keyrow >> 1;
        }
        keycol = keycol << 1 ;
        row_sel=0;
    }

    for ( i=0 ; i<=TOTAL_KEYS; i++) // get pressed button number
    {
        if (key_array[i])
            key_num = i;
    }

    LCD_Clear();
    LCD_IR_Buttons(key_num);

    P8DIR |= BIT0 + BIT1; //Set P8.0/8.1/1.1/2.5 as keypad output
    P1DIR |= BIT1;
    P2DIR |= BIT5;
    P8OUT &= ~(BIT0 + BIT1); //P8.0/8.1/1.1/2.5 output low
    P1OUT &= ~BIT1;
    P2OUT &= ~BIT5;

    return key_num;
}

/* NOTE: INTERESTING DEBOUNCE TIMER METHOD
 * Uses Watchdog timer as the button debouncer
 * When one of the keypad buttons are pressed (P1 and P2 interrupt, in main.c), the watchdog timer is started
 * Then 250ms later, interrupt occurs, and watchdog timer is reset.
 */

// Sets up the WDT as a button debouncer, only activated once a
// button interrupt has occurred.
void Buttons_startWDT()
{
    // WDT as 250ms interval counter
    SFRIFG1 &= ~WDTIFG;
    WDTCTL = WDTPW + WDTSSEL_1 + WDTTMSEL + WDTCNTCL + WDTIS_5;
    SFRIE1 |= WDTIE;
}


// Handles Watchdog Timer interrupts.
#pragma vector=WDT_VECTOR
__interrupt void WDT_ISR(void)
{
    if(buttonDebounce == 2) {
        buttonDebounce = 1; //button has cooled down

        //Reset watchdog timer
        SFRIFG1 &= ~WDTIFG;
        SFRIE1 &= ~WDTIE;
        WDTCTL = WDTPW + WDTHOLD;
    }
}

